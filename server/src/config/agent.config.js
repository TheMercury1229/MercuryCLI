import { promises as fs } from "fs";
import path from "path";
import chalk from "chalk";
import { generateObject } from "ai";
import { success, z } from "zod";
// SCHEMA OF THE APPLICATION FOR AI
const APPLICATION_SCHEMA = z.object({
  folderName: z.string().describe("Kebab-case name of the application folder"),
  description: z.string().describe("A brief description of the application"),
  files: z
    .array(
      z.object({
        path: z
          .string()
          .describe("File path relative to the application folder"),
        content: z.string().describe("Content of the file completed by the AI"),
      })
    )
    .describe("List of files to be created for the application"),

  setupCommands: z
    .array(
      z
        .string()
        .describe(
          "Bash commands to setup and run (e.g., npm install, npm start)"
        )
    )
    .describe("List of setup commands for the application"),
});

//AGENT PROMPT

function printSystem(message) {
  console.log(message);
}
function displayFileTree(files, folderName) {
  printSystem(chalk.cyan("\nüìÇ Project Structure: "));
  printSystem(chalk.white(`${folderName}/`));

  const filesByDir = {};
  files.forEach((file) => {
    const paths = file.path.split("/");
    const dir = paths.length > 1 ? paths.slice(0, -1).join("/") : "";
    if (!filesByDir[dir]) {
      filesByDir[dir] = [];
    }
    filesByDir[dir].push(paths[paths.length - 1]);
  });
  Object.keys(filesByDir)
    .sort()
    .forEach((dir) => {
      if (dir) {
        printSystem(chalk.white(`  ${dir}/`));
        filesByDir[dir].sort().forEach((file) => {
          printSystem(chalk.white(`    ${file}`));
        });
      } else {
        filesByDir[dir].sort().forEach((file) => {
          printSystem(chalk.white(`  ${file}`));
        });
      }
    });
}

async function createApplicationFiles(baseDir, files, folderName) {
  const appDir = path.join(baseDir, folderName);

  await fs.mkdir(appDir, { recursive: true });
  printSystem(chalk.gray(`Creating application directory at: ${appDir}`));
  for (const file of files) {
    const filePath = path.join(appDir, file.path);
    const dirPath = path.dirname(filePath);
    await fs.mkdir(dirPath, { recursive: true });
    await fs.writeFile(filePath, file.content, "utf8");
    printSystem(chalk.gray(`Created file: ${filePath}`));
  }
  return appDir;
}

export async function generateApplication(
  description,
  aiService,
  cwd = process.cwd()
) {
  const AI_AGENT_PROMPT = `Create a complete application based on the following description:${description}\n
        CRITICAL REQUIREMENTS:\n
        1.Generate ALL files required for a complete  application to run.\n
        2.Include a package.json with necessary dependencies with correct versions  and scripts.\n
        3.Include a README.md with instructions on how to setup and run the application.\n
        4.Include any configuration files required (e.g., next.config.js, .env.local.example,.gitignore).\n
        5.Write clean, well-structured,production-ready code.\n
        6.Include error handling and input validation where necessary.\n
        7.Use modern JavaScript/TypeScript features and best practices.\n
        8.Make sure all the imports and paths are correct.\n
        9.NO PLACEHOLDERS- everything must be filled out completely and fully functional.\n
        
        Provide:
        -A meaningful folder name for the application in kebab-case.
        -All necessary files with their paths and complete content.
        -Setup commands to install dependencies and run the application.\n
        -All dependecies with versions in package.json.\n`;

  try {
    printSystem(chalk.cyan("\nü§ñ Generating application structure...\n"));
    printSystem(chalk.gray(`Description: ${description}\n`));
    printSystem(chalk.magenta("ü§ñ Agent Response\n"));

    const { object: application } = await generateObject({
      model: aiService.model,
      schema: APPLICATION_SCHEMA,
      prompt: AI_AGENT_PROMPT,
    });

    printSystem(chalk.green(`\nGenerated :${application.folderName}\n`));
    printSystem(chalk.gray(`Description: ${application.description}\n`));
    if (application.files.length === 0) {
      throw new Error(" No files were generated by the AI.");
    }
    displayFileTree(application.files, application.folderName);
    printSystem(chalk.cyan("\nüíæ Writing files to disk...\n"));
    const appDir = await createApplicationFiles(
      cwd,
      application.files,
      application.folderName
    );
    printSystem(chalk.green("‚úÖ Application files created successfully.\n"));
    printSystem(chalk.cyan(`Location:${chalk.bold(appDir)}\n`));

    if (application.setupCommands.length > 0) {
      printSystem(chalk.cyan("üöÄ Setup Commands:\n"));
      printSystem(chalk.white("```bash"));
      application.setupCommands.forEach((cmd) => {
        printSystem(chalk.white(`${cmd}`));
      });
      printSystem(chalk.white("```\n"));
    }
    return {
      folderName: application.folderName,
      appDir,
      files: application.files.map((file) => file.path),
      commands: application.setupCommands,
      success: true,
    };
  } catch (error) {
    printSystem(chalk.red("‚ùå Error generating application:\n"));
    printSystem(chalk.red(error.message));
    return { success: false, error: error.message };
  }
}
